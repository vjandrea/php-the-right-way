---
isChild: true
title: Errori
---

## Errori {#errori_title}

In molti linguaggi di programmazione, ogni volta che qualcosa va storto viene lanciata un'eccezione. Questo è certamente
un modo fattibile di fare le cose, ma PHP è un linguaggio con poche eccezioni. Nonostante supporti le eccezioni e sempre
più del codice nativo stia usando a usarle quando si lavora con gli oggetti, la maggior parte di PHP cercherà di
continuare a processare indipendentemente da quello che accade, a meno che non avvenga un errore fatale.

Per esempio:

{% highlight php %}
$ php -a
php > echo $foo;
Notice: Undefined variable: foo in php shell code on line 1
{% endhighlight %}

Questo è solo un errore notice, e PHP continuerà felicemente. Questo può confondere chi viene da linguaggi con molte
eccezioni, perché riferirsi a una variabile mancante in Python, per esempio, lancia un'eccezione:

{% highlight python %}
$ python
>>> print foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
{% endhighlight %}

L'unica vera differenza è che Python andrà nel panico per ogni piccola cosa, in modo che gli sviluppatori possano essere
completamente sicuri che qualunque potenziale problema o caso limite sia coperto, mentre PHP continuerà a processare a
meno che non avvenga qualcosa di estremo; a questo punto lancerà un errore e lo riporterà.

### Gravità degli errori

PHP ha diversi livelli di gravità degli errori. I tre tipi più comuni di messaggi sono gli errori, i notice e i warning.
Questi hanno diversi livelli di gravità: `E_ERROR`, `E_NOTICE` e `E_WARNING`. Gli errori sono errori fatali che
avvengono durante l'esecuzione e sono solitamente causati da problemi nel tuo codice e devono essere sistemati perché
faranno fermare l'esecuzione di PHP. I warning sono errori non fatali: l'esecuzione dello script non viene fermata. I
notice sono messaggi di avviso causati da codice che potrebbe o meno causare problemi durante l'esecuzione dello script;
l'esecuzione non viene fermata.

Un altro tipo di messaggio di errore riportato durante la compilazione sono i messaggi `E_STRICT`. Questi messaggi sono
usati per suggerire cambiamenti al tuo codice per assicurare la migliore interoperabilità e compatibilità con le
versioni successive di PHP.

### Cambiare il metodo di segnalazione degli errori in PHP

Il segnalazione degli errori può essere cambiato usando le impostazioni di PHP e/o delle chiamate a funzioni PHP. Usando
la funzione nativa di PHP `error_reporting()` puoi impostare il livello degli errori per la durata dell'esecuzione dello
script passando una delle costanti di livello errore predefinite. Questo significa che se vuoi vedere solo warning ed
errori - ma non notice - allora puoi configurarlo così:

{% highlight php %}
error_reporting(E_ERROR | E_WARNING);
{% endhighlight %}

Puoi anche controllare se gli errori vengono visualizzati a schermo (ottimo per lo sviluppo) o se vengono nascosti, e
loggati (ottimo per la produzione). Per maggiori informazioni controlla la sezione
[Segnalazione degli errori][errorreport].

### Soppressione in linea degli errori

Puoi anche dire a PHP di sopprimere errori specifici usando l'operatore di controllo degli errori `@`. Metti questo
operatore all'inizio di un'espressione, e ogni errore che è un risultato diretto dell'espressione viene silenziato:

{% highlight php %}
echo @$foo['bar'];
{% endhighlight %}

Questo mostrerà `$foo['bar']` se esiste, ma restituirà semplicemente un valore nullo e non visualizzerà niente se la
variabile `$foo` o l'indice `'bar'` non esistono. Senza l'operatore di controllo degli errori, questa espressione
potrebbe creare un errore `PHP Notice:  Undefined variable: foo` o `PHP Notice:  Undefined index: bar`.

Questa potrebbe sembrare una buona idea, ma ci sono alcuni lati negativi. PHP gestisce le espressioni che usano un `@`
in maniera meno performante rispetto a quelle senza `@`. L'ottimizzazione prematura potrebbe essere la radice di tutti
i dibattiti sulla programmazione, ma se la performance è particolarmente importante per la tua applicazione/libreria,
è importante capire le conseguenze che l'operatore di controllo degli errori avrà sulla performance.

In secondo luogo, l'operatore di controllo degli errori **inghiotte** completamente l'errore. L'errore non viene
mostrato, e l'errore non viene mandato al log degli errori. Inoltre, i sistemi PHP di produzione non hanno modo di
disabilitare l'operatore di controllo degli errori. Nonostante l'errore che vedi potrebbe essere innocuo, un errore
differente e meno innocuo verrebbe ugualmente silenziato.

Se c'è un modo di evitare l'operatore di soppressione degli errori, dovresti consdierarlo. Per esempio, il nostro codice
sopra potrebbe essere riscritto così:

{% highlight php %}
echo isset($foo['bar']) ? $foo['bar'] : '';
{% endhighlight %}

Un caso in cui la soppressione degli errori potrebbe avere senso è quando `fopen()` non trova il file da caricare.
Potresti controllare l'esistenza del file prima di provare a caricarlo, ma se il file viene cancellato dopo il controllo
e prima di `fopen()` (il che potrebbe sembrare impossibile, ma può accadere) allora `fopen()` restituirà false _e_
lancerà un errore. Questo è potenzialmente qualcosa che PHP dovrebe risolvere, ma è un caso in cui la soppressione degli
errori potrebbe sembrare l'unica soluzione valida.

Prima abbiamo detto che non c'è modo in un sistema PHP tradizionale di disabilitare l'operatore di controllo degli
errori. Tuttavia, [xDebug] ha un'impostazione ini `xdebug.scream` che disabilita l'operatore di controllo degli errori.
Puoi impostarlo nel tuo `php.ini` scrivendo:

    xdebug.scream = On

Puoi anche impostare questo valore durante l'esecuzione con la funzione `ini_set`:

{% highlight php %}
ini_set('xdebug.scream', '1')
{% endhighlight %}

L'estensione PHP "[Scream]" offre una funzionalità simile a quella di xDebug, ma l'impostazione ini di Scream si chiama
`scream.enabled`.

Questo è particolarmente utile quando stai debuggando del codice e sospetti che un messaggio di errore informativo
venga soppresso. Usa scream con cura, come uno strumento di debugging temporaneo. Ci sono molte librerie PHP che
potrebbero non funzionare con l'operatore di controllo degli errori disabilitato.

* [Operatore di controllo degli errori](http://php.net/manual/en/language.operators.errorcontrol.php)
* [SitePoint](http://www.sitepoint.com/)
* [xDebug](http://xdebug.org/docs/basic)
* [Scream](http://www.php.net/manual/en/book.scream.php)

### ErrorException

PHP è perfettamente in grado di essere un linguaggio fortemente orientato alle eccezioni, e richiede solo qualche linea
di codice per fare il cambio. Fondamentalmente puoi lanciare i tuoi "errori" come "eccezioni" usando la classe
`ErrorException`, che estende la classe `Exception`.

Questa è una pratica comune implementata da un grande numero di framework moderni come Symfony e Laravel. Di default
Laravel visualizzerà tutti gli errori e le eccezioni usando il pacchetto [Whhops!] se l'interruttore `app.debug` è
acceso, oppure li nasconderà se l'interruttore è spento.

Lanciando gli errori come eccezioni durante lo sviluppo puoi gestirli meglio del solito risultato, e se vedi
un'eccezione durante lo sviluppo puoi racchiuderla in un'istruzione di cattura con codice specifico per gestire la
situazione. Ciascuna eccezione che catturi rende istantaneamente la tua applicazione un po' più robusta.

Maggiori informazioni su questo e su come usare la classe `ErrorException` per gestire gli errori si possono trovare su
[classe ErrorException][errorexception].

* [Operatore di controllo degli errori](http://php.net/manual/en/language.operators.errorcontrol.php)
* [Costanti predefinite per la gestione degli errori](http://www.php.net/manual/en/errorfunc.constants.php)
* [error_reporting](http://www.php.net/manual/en/function.error-reporting.php)
* [Segnalazione degli errori][errorreport]

[errorexception]: http://php.net/manual/en/class.errorexception.php
[errorreport]: /#segnalazione_degli_errori
[Whoops!]: http://filp.github.io/whoops/
